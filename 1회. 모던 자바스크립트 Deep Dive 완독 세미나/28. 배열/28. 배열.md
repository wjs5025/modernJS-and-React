# 28. 배열 / 발표자 : 전인혁

# 배열이란?

- 1개이 변수에 여러 개의 값을 순차적으로 저장할 때 사용.
- 자바스크립트에서 배열은 객체이며, 유용한 내장 메소드를 포함한다.
- Array 생성자로 생성된 Array 타입의 객체.
- 프로토타입 : Array.prototype

# 배열의 특징

- 인덱스가 존재하며, 첫번째 값은 인덱스 0이고, 마지막 인덱스는 Array.length - 1이다.
- 존재하지 않는 요소에 접근하면, undefined를 반환한다.
- 같은 데이터 타입만 조합할 수 있는 타언어와 다르게, 자바스크립트의 배열은 어떤 타입의 조합이라도 포함할 수 있다.

# 배열의 생성

- 배열 리터럴 방식
- 생성자 함수 Array를 통한 방식

## 배열 리터럴 방식

- 0 개 이상의 값을 쉼표로 구분하여 대괄호로 묶는다.

```js
let array = ["a", "b"];
array[1]; // "b"
array[2]; // undefined
array.length; // 2
typeof array; // object

// 유사하게 객체 리터럴로 표현하면 다음과 같다
// 배열 리터럴은 객체 리터럴과 다르게 프로퍼티 명이 없고, 값만 존재한다.
// 배열은 프로퍼티 값에 접근시, 대괄호 표기법([index]) 만 사용 가능하다.
// 또 다른 차이는, 근본적인 차이인데, 프로토타입 객체가 다르다는 점이다. (배열 : Array.prototype / 객체 : Object.prototype)

let obj = { 0: "a", 1: "b" };
let array.0 // Error
```

## 생성자 함수 Array()를 통한 방식

- 배열 리터럴과 똑같이 동작한다.
- Array()는 매개변수의 갯수에 따라 다르게 동작한다.

```js
// 매개변수가 1개이고 숫자일 때
const arr_1 = new Array(3);
console.log(arr_1); // (3) [empty x 3]

// 매개변수가 1개이고 숫자가 아닐 때
const arr_2 = new Array("A");
console.log(arr_2); // ["A"]

// 그 외의 경우 (매개변수가 2개 이상일 때)
const arr_3 = new Array(1, "가", "A");
console.log(arr_3); // [1,"가","A"]
```

# 배열 요소의 추가/삭제

## 배열 요소의 추가

- 배열은 동적으로 요소를 추가할 수 있다.
- 배열의 길이(length)는 마지막 인덱스를 기준으로 산정된다.
- 인덱스 중간중간에 원소가 비어있을 경우, empty(비어있음)으로 표기된다.

```js
const arr = [];

// 인덱스로 삽입
arr[1] = 1;
arr[3] = 3;
console.log(arr); // [empty, 1, empty , 3]

// push() 메소드 활용
arr.push(4);
console.log(arr); // [empty, 1, empty, 3, 4]

arr.length; // 5

// 값이 할당되지 않은 인덱스 위치의 요소는 생성되지 않는다.
console.log(Object.keys(arr)); // [ '1', '3' ]
```

## 배열 요소의 삭제

- 배열도 객체이므로, delete 연산자를 사용할 수 있다. (단, length에는 변화가 없다.)
- 요소를 완전히 삭제(length 변화까지)하기 위해서는 Array.prototype.splice(startIndex, elementCnt) 메소드를 사용해야 한다.

```js
const arr = ["a", "b", "c", "d"];

delete arr[3];
console.log(arr); // ["a","b","c",empty]
console.log(arr.length); // 4

arr.splice(2, 1); // "c"
console.log(arr); // ["a","b",empty]
```

# 배열의 순회

- 객체 순회시에는 for...in 문을 사용하지만, 배열 순회시에는 적합하지 않다. (불필요한 프로퍼티까지 순회할 수 있어서, 또한 키를 출력하기 때문에)
  -> 배열의 순회에는 forEach, for문, for...of 문을 사용하는 것이 좋다.

```js
const arr = [0, 1, 2, 3];
arr.example = 4;
let answer = "";
for (const key in arr) {
  answer += key;
}
// 01234
// 이때 4는 불필요한 프로퍼티(arr.example)의 값

// 권장하는(정상적인) 방법
// 1. forEach
arr.forEach((item, index) => console.log(`${index}번째 아이템 ${item}`));

// 2. for
for (let i = 0; i < arr.length; i++) {
  console.log(`${i}번째 아이템 ${arr[i]}`);
}

// 3. for...of
for (let i of arr) {
  console.log(`아이템 ${i}`);
}
```

# Array의 프로퍼티

- Array.length

## Array.length

- 요소의 개수(배열의 길이)를 나타낸다.
- 배열의 인덱스는 32bit 양의 정수로 처리 되기 때문에, 최대 값은 2^23 - 1(=== 4,294,967,296 - 1)이다.

```js
arr = [];
console.log(arr.length); //0

arr[4294967294] = 100;
console.log(arr); // [empty x 4294967294, 100]
console.log(arr.length); // 4294967295

arr[4294967295] = 1001;
console.log(arr); // [empty x 4294967294, 100, 1001]
console.log(arr.length); // 4294967295
```

**위 예시를 보았을 때, length 프로퍼티의 값과 배열 요소의 실제 개수가 반드시 일치하지는 않는 것을 확인할 수 있다.**
-> 위와 같은 배열을 **희소배열**이라고 부른다.
-> 희소 배열은 배열의 요소가 연속적이지 않은 배열을 의미함.
-> 희소배열은 일반 배열보다 느리고, 메모리를 낭비한다. (지양해야 한다)

- 현재의 length 프로퍼티 값보다 더 큰 인덱스로 요소를 추가하면 자동으로 length가 늘어난다.
- length 값은 명시적으로 변경할 수 있고, 현재보다 작게 변경하면 값에 맞게 해당 인덱스 뒤의 원소는 모두 삭제한다.

```js
let arr = [];
arr[5] = 3;
console.log(arr); // [empty x 5, 3]
console.log(arr.length); // 6

arr.length = 3;
console.log(arr); // [empty x 3]
console.log(arr.length); // 3
```

# Array의 메소드

- Array 메소드의 종류는 원본 배열의 변경여부에 따라 2개로 나뉜다.
- 이번 시간에는 다음과 같은 메소드들을 배울것이다.
  isArray(), from(), of(), indexOf(), concat(), join(), push(), pop(), reverse(), shift(), slice(), splice()

## Array.isArray(arg:any) : boolean (ES5)

- 정적메소드로, 배열인지 여부를 판단 하여 boolean 값을 반환한다.
- 인수가 배열이면 true, 아니면 false를 반환한다.

```js
Array.isArray([]); // true
Array.isArray(new Array()); // true
Array.isArray("Array"); // false
Array.isArray(null); // false
```

## Array.from() (ES6) \*\*\*

- ES6에서 도입되었으며, 유사배열 객체 또는 이터러블(iterable) 객체를 변환하여 새로운 배열을 생성.

```js
let str = "Jeon";
Array.from(str); // ["J", "e", "o", "n"] - 문자열은 이터러블.

let array_like = { length: 3, 0: "a", 1: "b" };
Array.from(array_like); // ["a", "b"] - 유사배열 객체를 배열로 변환

// 응용 (배열 변환과 동시에 함수 전달 - map 처럼)
Array.from(array_like, (item, index) => {
  console.log(item, index);
});
```

## Array.of (ES6) \*\*

- ES6에서 도입되어쓰며, 전달된 인수를 요소로 갖는 배열을 생성.
- 생성자 함수와 다르게, 전달된 인수가 1개이고, 숫자일 때 인수를 요소로 갖는 배열을 생성.

```js
// Array.of vs 생성자 함수
let arr_1 = Array.of(1);
console.log(arr_1); // [1]

let array_constructor = new Array(1);
console.log(array_constructor); // [empty]

let arr_2 = Array.of(1, 2, 3);
console.log(arr_2); // [1, 2, 3]

let arr_3 = Array.of("string");
console.log(arr_3); // ["string"]
```

## Array.prototype.indexOf(searchElement : T, fromIndex? : number) : number (ES5)
