# 배열 고차 함수 / 발표자 : 전인혁

# 고차함수란?

- 함수를 인자로 전달받거나 함수를 결과로 반환하는 함수.
  -> 자바스크립트에서 함수는 일급 객체이므로, 값처럼 인자로 전달할 수 있으며 반환 가능.
- 고차 함수는, 인자로 받은 **함수를 필요한 시점에 호출하거나, 클로저를 생성하여 반환**
- 함수형 프로그래밍에 기반을 둔다.

## 함수형 프로그래밍의 특징

- 외부 상태 변경이나 가변(mutable) 데이터를 피하고, 불변성(immutability)을 지향
- 순수 함수(pure function)와 보조함수의 조합으로 로직 내에 존재하는 조건문(if)과 반복문(for)을 제거하여 복잡성을 해결. -> 조건문과 반복문은 로직의 흐름을 어렵게 한다.(가독성 저하, 불변성을 해침, 오류 발생률 증가)
- 순수 함수를 사용하여, 부수효과를 최대한 억제 -> 안정성 향상
- 변수의 사용을 억제하여 상태변경을 피함.

```js
// 고차함수 makeCounter(function) : funtion
function makeCounter(predicate) {
  let num = 0; // ㅇㅇ 변수

  // 클로저 - num의 상태를 유지한다.
  return function () {
    num = predicate(num);
    return num;
  };
}

function increase(n) {
  return ++n;
}

function decrease(n) {
  return --n;
}

// makeCounter는 함수를 인수로 전달받는다. 클로저를 반환.
const increaser = makeCounter(increase);
console.log(increaser()); // 1
console.log(increaser()); // 2

// makeCounter는 함수를 인수로 전달받는다. 클로저를 반환.
// (별개의 자유변수가 선언되었기 때문에, increaser의 자유변수 num과는 공유되지 않는다.)
const decreaser = makeCounter(decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

# Array의 고차 함수

- 배열에는 수많은 고차 함수(메소드)가 있다.
- 오늘은 sort(), forEach(), map(), filter(), reduce(), some(), every(), find(), findIndex()를 알아볼 예정. (아는 메소드도 있죠?)

## Array.prototype.sort(compareFn?:(a:T, b:T)=>number):this

- 원본 배열을 정렬하고, 해당 배열(this)을 반환
- 참고 / 기존 자바스크립트에서는 Quicksort를 사용했으나, ECMAScript 2019 이후로는 Timsort 알고리즘을 사용. (안정성 증가)
- 기본적으로 Unicode 포인트 순서(사전 순과 유사)에 따르기 때문에, 임의로 문자열로 변환 후 정렬한다.
  -> 숫자 정렬시 문제가 발생한다. (10과 2 정렬 시에는?)
  -> 이때는, 비교 함수를 인수로 전달한다.

### 비교 함수

- 오름차순 (return a-b) : 비교 함수의 반환 값이 0보다 작으면, a를 우선하여 정렬한다.
- 내림차순 (return b-a) : 비교 함수의 반환 값이 0보다 크면, b를 우선하여 정렬한다.

```js
/* 문자열 정렬 */
const brands = ["Samsung", "Hyundai", "Apple", "Google"];

// 오름차순
brands.sort();
console.log(brands); // ["Apple", "Google", "Hyundai", "Samsung"]

// 오름차순 -> 내림차순 (역으로)
brands.reverse();
console.log(brands); // ['Samsung', 'Hyundai', 'Google', 'Apple']

/* 숫자 정렬 */
const points = [40, 100, 1, 5, 2, 25, 10];

// 잘못된 결과
points.sort(); // [1, 10, 100, 2, 25, 40, 5]

// 정상적인 결과
points.sort((a, b) => a - b); // [1, 2, 5, 10, 25, 40, 100]

/* 객체 정렬 */
const students = [
  { id: 4, name: "Park" },
  { id: 1, name: "Kim" },
  { id: 2, name: "Jeon" },
  { id: 5, name: "Lee" },
];

// 당연하게도, 비교 함수를 분리할 수도 있다.
// 아래 예제에서는 클로저를 활용했다. (key : 어떤 프로퍼티를 기준으로 비교할지)

function compare(key) {
  return function (a, b) {
    return a[key] > b[key] ? 1 : a[key] < b[key] ? -1 : 0;
    // 산술 연산(-) 사용 시, 문자열에서는 NaN가 나오므로, 삼항연산 조건식을 활용한다.
  };
}

// id 정렬 오름차순
students.sort(compare("id")); // [{id: 1, name: 'Kim'}, {id: 2, name: 'Jeon'}, {id: 4, name: 'Park'}, {id: 5, name: 'Lee'}

// name 정렬 오름차순
students.sort(compare("name")); // [{id: 2, name: 'Jeon'}, {id: 1, name: 'Kim'}, {id: 5, name: 'Lee'}, {id: 4, name: 'Park'}]
```

## Array.prototype.forEach(callback : (value:T, index:number, array:T[]) => void, thisArg?:any) : void

- for문 대신 사용가능.
- 배열을 순회하면서, 각 요소에 대해 인자로 주어진 콜백함수 실행.
- void 함수이기 때문에, 반환 값은 undefined.
- 콜백 함수의 매개변수를 통해 특정 값들을 전달 받을 수 있다.
  -> 배열 요소의 값(item)
  -> 배열 요소의 인덱스(index)
  -> this (forEach 메소드를 호출한 자기 자신 배열, array)
- forEach 메소드는 원본 배열을 변경하지 않으나, 콜백함수가 전달된 원본배열(this)를 변경할 수는 있다.
- break문을 사용할 수 없기에, 모든 요소를 순회 해야한다.
- for문에 비해 성능이 좋지 않으나, 가독성이 뛰어나서 사용을 권장하는 편이다.

```js
// 철수, 박수, 남수, 그리고 혁수는 모두 아버지가 "김"씨, 어머니가 "박"씨인 자녀들이다
// 배열을 수정해서 (아버지성 + 어머니성 + 이름) 형태로 재구성하자.
const name = ["철수", "박수", "남수", "혁수"];

/* for문 vs forEach */
// for문
for (let i = 0; i < name.length; i++) {
  name[i] = "김" + name[i];
}
console.log(name); // ['김철수', '김박수', '김남수', '김혁수']

// forEach 문
name.forEach((item, index, self) => {
  self[index] = "박" + item;
});
console.log(name); // ['김박철수', '김박박수', '김박남수', '김박혁수']

[1,2,3].forEach(function (item, index, self) {
    if (index > 1) break;
}) // 문법 Error : Illegal break statement
```

### forEach 구현해보기

```js
Array.prototype.myForEach = function (f) {
  // 첫번째 매개변수에 함수가 전달되었는지 확인
  if (!f || Object.prototype.toString.call(f) !== "[object Function]") {
    throw new TypeError(`${f} is not a function.`);
  }

  for (let i = 0; i < this.length; i++) {
    f(this[i], i, this); // 값, 인덱스, f를 호출한 배열(this)
  }
};

// arr의 각 요소를 현재 인덱스 값을 더한 값으로 바꿔라
const arr = [0, 0, 0, 0];

Object.toString.call(() => {});
arr.myForEach((item, index, self) => {
  self[index] = item + index;
});
console.log(arr);
```
