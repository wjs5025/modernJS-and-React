# 클로저(Closure)?

- 함수를 일급객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성 중 하나.
- MDN 에서는 "함수와 그 함수가 선언됐을 때의 렉시컬 환경과의 조합" 이라고 정의함.
  -> 이때의 "그 함수가 선언됐을 때의 렉시컬 환경"은 **내부 함수가 선언됐을 때의 스코프**를 말함
- 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억해서, 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수
  -> 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수

```js
// 이 예제에서, innerFunc에서도 outerFunc의 변수 x에 접근할 수 있다.
function outerFunc() {
  let x = 10;
  let innerFunc = function () {
    console.log(x);
  };

  innerFunc();
}

outerFunc();
```

# 렉시컬 스코프

- 스코프가 함수를 호출할 때가 아닌, **함수를 어디에 선언했는지**에 따라 결정되는 것

# 클로저 예제

- 아래 예제에서, outerFunc는 내부함수(innerFunc)를 반환하고 소멸.
- return을 하면서, 실행 컨텍스트 스택에서 제거되었으므로, outerFunc 의 변수 x는 유효하지 않을 것으로 예상됨.
  -> 하지만, x는 10으로 정상 출력된다.
  -> 이처럼, 자기 자신을 포함하는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 **외부함수의 지역 변수에 접근할 수 있는 함수** (예제의 반환된 innerFunc).
  - 이때, 클로저에 의해 참조되는 외부함수의 변수를 자유변수(Free Variable)라고 부른다.

```js
// 내부함수 innerFunc를 함수 outerFunc에서 반환하도록 변경.
function outerFunc(){
    let x = 10;
    let innerFunc() = function () { console.log (x); };
    return innerFunc()
}

let inner = outerFunc();
inner(); // 10
```

# 실행 컨텍스트의 관점에서..

[실행 컨텍스트와 클로저](./pictures/%EC%8B%A4%ED%96%89%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80%20%ED%81%B4%EB%A1%9C%EC%A0%80.png)

- 내부 함수가 살아있는 상태에서, 외부 함수의 컨텍스트가 소멸되어도, 외부함수 실행 컨텍스트 내의 활성객체에 스코프 체인을 통해 참조할 수 있다.
  -> 외부함수가 이미 반환되었어도, 외부함수 내의 변수는 이를 필요로 하는 내부함수가 하나 이상 존재하는 경우 계속 유지됨.
  -> **이때, 외부함수 변수의 복사본이 아닌, 변수 원본에 접근한다는 것에 주의**

# https://poiemaweb.com/js-closure#2-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%98-%ED%99%9C%EC%9A%A9 부터
