> 9/29 / 발표자 : 전인혁

# 실행 컨텍스트

- Scope, Hoisting, this, function, closure 등의 동작 원리를 담고 있는 자바스크립트의 핵심 원리.
- 이를 이해하지 못한다면, 코드 독해와 디버깅이 어려워짐.

## ECMAScript 스펙에서는 **실행 가능한 코드를 형상화하고 구분하는 추상적인 개념**이라고 정의하였다.

- 실행 가능한 코드가 실행되기 위해 필요한 환경이라고 할 수 있다.

## 실행가능한 코드란?

- 전역 코드 : 전역 영역에 있는 코드
- 함수 내 코드 : 함수 내에 존재하는 코드
- Eval 코드 : eval()로 실행되는 코드 \* eval() : 문자열 또는 숫자식의 결과를 계산 / 잘 쓰이지는 않음

## 코드가 실행되기 위한 정보

- 변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티
- 함수 선언
- 변수의 유효 범위(Scope)
- this

# 자바스크립트 엔진은 필요한 정보를 형상화하고, 구분하기 위해 실행 컨텍스트를 물리적 객체의 형태로 관리한다.

![실행 컨텍스트 스택](./pictures/%EC%8B%A4%ED%96%89%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%20%EC%8A%A4%ED%83%9D.png)

```js
var x = "xxx";

function foo() {
  var y = "yyy";

  function bar() {
    var z = "zzz";
    console.log(x + y + z);
  }
  bar();
}
foo();
```

**동작 원리**

- 코드 실행 시, 컨테스트 스택(Stack)이 생성/소멸 됨.
- 현재 실행 중인 컨텍스트에서, 해당 컨텍스트와 관련 없는 코드(ex : 함수)가 실행되면, 새로운 컨텍스트 생성.
- 컨텍스트는 스택에 쌓이고, 제어권이 이동함.

**과정**

- 전역코드(global code)로 컨트롤이 진입하면, 전역 실행 컨텍스트가 생성 (global EC)되고 스택에 쌓임.
  -> 전역 실행 컨텍스트(global EC)는 애플리케이션(웹 페이지 이탈 또는 브라우저를 닿을 때까지)이 종료될때까지 유지됨 (**브라우저의 window 객체를 사용할 수 있는 이유**)
- 함수를 호출하면 해당 함수의 컨텍스트가 실행 컨텍스트 스택에 쌓임
- 함수 실행이 끝나면 해당 함수의 컨텍스트를 파기하고, 이전 컨텍스트에 컨트롤을 반환

# 실행 컨텍스트의 3가지 객체

- 추상적인 개념이지만, 물리적으로는 객체의 형태를 가짐. (실행컨텍스트 === 객체)
- 3개의 프로퍼티를 가진다.

1. Variable Object : vars, function declarations, arguments...
2. Scope chain : [Variable object + all parent scopes]
3. thisValue : context object

## Variable Object (VO / 변수 객체)

- 코드 실행에 필요한 정보 (변수, 함수 선언, 매개변수와 인수(arguments) 등)를 담는 객체
- 코드가 실행될 때, 엔진에 의해 참조되는데, 코드에서는 접근할 수 없음.
- 각 컨텍스트는 Variable Object를 갖는다.
- 전역 컨텍스트와 함수 컨텍스트는 각각 다른 Variable Object를 가리킨다. (전역 코드와 함수의 내용이 달라서)

### 전역 컨텍스트 및 함수 컨텍스트의 VO, 어떻게 다를까?

[전역 컨텍스트와 함수 컨텍스트의 프로퍼티](./pictures/%EC%A0%84%EC%97%AD%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80%20%ED%95%A8%EC%88%98%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0.png)

- 전역 코드에는 매개변수가 없지만, 함수에는 있다.
- 전역 컨텍스트의 Variable Object는 전역 객체(global Object / GO)를 가리킴.
  -> GO는 전역에 선언된 전역변수, 전역함수를 프로퍼티로 소유
- 함수 컨텍스트의 Variable Object는 활성 객체(Activation Object / AO)를 가리킴.
  -> AO는 함수 내부에 선언된 지역 변수, 내부함수를 프로퍼티로 소유. 추가로, arguments 객체가 추가됨
  -> arguments 객체 : 매개변수와 인수들의 정보를 배열의 형태로 담고 있는 객체인

## Scope Chain(SC) \*\*

[전역 컨텍스트와 함수 컨텍스트의 스코프 체인](./pictures/%EC%A0%84%EC%97%AD%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80%20%ED%95%A8%EC%88%98%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84%20%EC%B2%B4%EC%9D%B8.png)

- 일종의 리스트인데, 해당 컨텍스트에서 참조할 수 있는 전역 객체(GO) 또는 활성 객체(AO)의 목록의 레퍼런스 값을 가진다.
- 활성 객체가 앞쪽 인덱스로오고, 전역 객체가 마지막 인덱스에 위치함. (그림 참고)
- 식별자 중에서, 객체의 프로퍼티가 아닌 식별자, 즉 변수를 검색하는 메커니즘임.
  -> 프로퍼티와 메소드를 검색하는 메커니즘은 프로토타입 체인
- 목적 : 렉시컬 스코프를 파악
  -> 하위 함수의 스코프 체인에 부모 함수의 스코프가 포함되기 때문.
  -> 함수가 중첩되었을 때, 하위 함수에서 상위함수의 스코프와 전역 스코프를 참조할 수 있는 이유
- 프로토타입 체인과 비슷하게, 현재 활성 객체에서 검색 실패했을 시, 스코프체인에 담긴 순서대로 검색을 반복
- 스코프 체인은 [[Scope]] 프로퍼티로 참조할 수 있다.

```js
function foo2() {
  console.dir(foo2);
  let foo3 = () => {
    console.dir(foo3);
  };
  foo3();
}
```

## this value

- this 프로퍼티에는 각 컨텍스트의 this 값이 할당 됨.
- 할당되는 값은 함수 호출 패턴에 의해 결정됨.

# 실행 컨텍스트의 생성 과정(5단계)

1. 초기 상태

- 컨트롤(제어권)이 실행 컨텍스트에 진입하기 전, 유일한 전역 객체(Global Object)가 생성됨.
  -> 초기 전역 객체에는 빌트인 객체와 BOM, DOM이 설정되어 있음.

2. 전역 실행 컨텍스트의 생성

- 컨트롤이 전역 코드로 진입하면, 전역 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 쌓임.

3. 스코프 체인의 생성과 초기화

- 스코프 체인이 만들어지고, 초기화한다. (스코프 체인의 0번 원소가 전역 객체의 참조값이 되도록)

4. 변수 객체화 (Variable Instantiation) 실행 \*\*\* (보통은 영어로 많이 읽는다.)

- Variable Instantiation이란, VO에 프로퍼티와 값을 추가하는 것.
- 변수, 매개변수, 인수(arguments), 함수 선언 등의 정보를 객체에 담는 것.
  **전역 컨텍스트의 경우엔? VO = GO 참조값이 담긴다**

  ### 변수 객체화 순서(3단계)

  1. (함수 내 코드(함수 코드 / function code)인 경우) 매개변수가 VO의 프로퍼티로, 인수가 값으로 설정됨.
  2. 대상 코드 내의 함수 선언(**함수 표현식 제외**, 함수 표현식의 경우엔 일반 변수 방식을 따름.)을 대상으로,
     함수명이 프로퍼티로, 생성된 함수 객체가 값으로 설정됨. (컨텍스트의 VO에, 전역 컨텍스트의 경우 GO에) (함수 호이스팅)

  - ex) foo : Function Object
  - 생성된 함수 객체 또한 [[Scope]] 프로퍼티를 가진다.
  - 현재 실행 컨텍스트의 스코프 체인이 참조하고 있는 객체를 값으로 설정. (부모 함수(외부함수)의 실행환경과 전역 객체 포함)
  - 이때, 외부함수의 실행 컨텍스트가 소멸되어도, [[Scope]] 프로퍼티가 가리키는 외부함수의 실행환경은 소멸하지 않고 참조가능. === 이것이 바로 클로저 !

  3.  대상 코드 내의 변수 선언을 대상으로, 변수명이 프로퍼티로, undefined가 값으로 설정됨. (변수 호이스팅)

  - 3가지 단계로 세분화할 수 있음.
    -> 선언 단계 : 변수 객체(VO)에 변수를 등록. (이때부터 스코프가 참조 가능하게 됨)
    -> 초기화 단계 : 변수 객체에 등록된 변수를 메모리에 할당. / 이때 변수는 undefined로 초기화됨 / var 키워드는 1. 선언 단계와 2. 초기화 단계가 동시에 일어난다.
    -> 할당 단계 : undefined로 초기화된 변수에 실제 값을 할당함.

5. this value 결정.

- 변수 선언 처리까지 끝난 후, this value가 결정된다.
- 컨텍스트의 this 프로퍼티는 이전에 전역 객체(GO)를 가리키고 있다가, 함수 호출 패턴에 의해 this에 할당되는 값이 결정된다.
- 전역 코드의 경우 this는 전역 객체(GO)를 가리킴.

# 전역 컨텍스트(전역 코드)의 경우, Variable Object, 스코프 체인, this 값은 언제나 전역 객체이다.

# 위의 단계까지가 코드 실행 환경을 갖추기 위한 단계. 아래부터는 코드의 실행에 관해 다룬다.

```js
var x = "xxx";

function foo() {
  var y = "yyy";

  function bar() {
    var z = "zzz";
    console.log(x + y + z);
  }
  bar();
}

foo();
```

- 선언은 모두 처리를 했으니, 할당과 호출만을 파악한다.
- x에 "xxx"를 할당하고, foo()를 호출

## 변수 값의 할당

- 현재 실행 컨텍스트의 스코프 체인을 0번부터 검색(VO), 변수명에 해당되는 프로퍼티가 발견되면, 해당 프로퍼티에 값을 할당

## 함수의 실행

- 전역 코드의 함수가 실행되면 새로운 함수 실행 컨텍스트가 생성됨.
- 해당 함수의 실행 컨텍스트로 컨트롤이 이동하면, 전역과 마찬가지로 실행 단계가 순차적으로 실행됨. (선언 ~)
  (스코프 체인 생성/초기화 시, 변수객체화시, this value 결정시에, 전역이 아닌 함수코드의 룰을 따름)

### 함수코드의 룰을 따르는 부분

1. 스코프 체인의 생성과 초기화에 관한 규칙

[함수 코드의 스코프 체인과 활성 객체](./pictures/%ED%95%A8%EC%88%98%20%EC%BD%94%EB%93%9C%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84%20%EC%B2%B4%EC%9D%B8%EA%B3%BC%20%ED%99%9C%EC%84%B1%20%EA%B0%9D%EC%B2%B4.png)

[함수 코드의 스코프 체인과 활성 객체 최종](./pictures/%ED%95%A8%EC%88%98%20%EC%BD%94%EB%93%9C%EC%9D%98%20%EC%8A%A4%EC%BD%94%ED%94%84%20%EC%B2%B4%EC%9D%B8%EA%B3%BC%20%ED%99%9C%EC%84%B1%20%EA%B0%9D%EC%B2%B4%20%EC%B5%9C%EC%A2%85.png)

- 활성 객체 생성 시, arguments 객체가 먼저 초기화 되고, 그 다음 변수 객체화가 실행된다.
- 그 다음, Caller가 참조하고 있는 객체들(부모 객체의 VO 또는 GO)이 스코프체인에 push된다.
- AO의 변수 객체화 또한 전역 코드와 같은 처리가 수행된다.
- this value가 함수 호출 패턴에 의해 결정된다.
- 함수가 실행되고, 내부 함수가 존재한다면 또 다른 컨텍스트가 생성되고 같은 과정이 반복된다.

[중첩함수의 실행 컨텍스트](./pictures/%EC%A4%91%EC%B2%A9%ED%95%A8%EC%88%98%EC%9D%98%20%EC%8B%A4%ED%96%89%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.png)

```js
// 문제 (호이스팅 관련)
// 각 함수와 변수의 선언이 처리되는 순서는?

function func1(value) {
  return value + 1;
}

let a = 3;
let b = 5;

function func2(value) {
  function func3(value) {
    return value + 3;
  }
  return value + 2;
}

let c = 9;

// 정답 : func1 - func2 - a - b - c
```
