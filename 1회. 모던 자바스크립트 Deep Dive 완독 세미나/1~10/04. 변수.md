### 변수란?

하나의 값을 저장하기 위해 확보한 메모리 공간 자체.

또는 그 메모리 공간을 식별하기 위해 붙인 이름.

**즉, 값의 위치를 가리키는 상징적인 이름.**

→ 컴파일러 또는 인터프리터에 의해 메모리 공간의 주소로 치환되어 실행됨.

(개발자가 직접 메모리에 접근할 필요없이, 변수를 통해 안전하게 값에 접근 가능.)

### 할당(Assignment)

변수에 값을 저장하는 것. (=대입, 저장)

### 참조(Reference)

변수에 저장된 값을 읽어 들이는 것.

### 코드는 개발자를 위한 문서이다. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 하고, 협업과 품질향상에 큰 도움을 준다.

→ 따라서 변수 이름을 지을 때는 첫 아이 이름을 짓듯이 신중하게 지어야 한다.

### 식별자(Identifier)

변수 이름을 식별자라고도 하며, 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 뜻함.

식별자는 변수의 값이 아니라, 메모리 주소를 기억하고 있다.

### 식별자라는 용어는 변수 이름에만 국한해서 사용하지 않고, 변수, 함수, 클래스 등의 이름은 모두 식별자이다.

→ 즉, 메모리 상에서 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

### 유의점.

- 변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 한다.
- 선언(declaration)에 의해 자바스크립트 엔진에 식별자의 존재를 알려야 한다.

### 변수 선언(Variable Declaration)

변수를 생성하는 것.

⇒ 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결(Name Binding)해서 값을 저장할 수 있게 준비하는 것.

**한번 선언한 변수는 확보가 해제(Release)되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.**

### var, let, const

ES6 이전에는 var 키워드가 변수를 선언하기 위한 유일한 키워드로 사용되었음.

하지만, ES6 이후로는 var의 단점을 보완하기 위해 let, const를 사용.

### var의 단점?

대표적인 단점은 블록 레벨 스코프(Block-level Scope)를 지원하지 않고, 함수 레벨 스코프(Function-level Scope)를 지원한다는 점이다.

→ 이로인해 의도치 않게 전역변수가 선언되어 심각한 부작용이 발생하기도 함.

### ES5와 ES6

ES6에서 let, const가 도입되었다해서 var 키워드가 폐기된 것은 아님. ES6 이전 사양으로 작성된 코드는 var 키워드로 구현되어 있는데, ES6 기반의 자바스크립트 엔진을 사용하더라도 정상 동작한다.

⇒ 즉, ES6는 기본적으로 하위 호환성을 유지하면서, ES5의 기반 위에 새로운 기능을 추가한 것이다. **다시말해, ES6는 ES5의 상위 집합이라고 할 수 있다.**

ES5를 잘 이해하고 있다면, ES6를 더욱 빠르고 명확하게 이해할 수 있으므로, 학습이 필요하다.

### 키워드란?

자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령. 예를 들어, var 키워드를 만나면 뒤에 오는 변수 명으로 새로운 변수를 생성한다. 아래 예시 코드에서 bold 처리된 단어가 키워드.

```jsx
**var** score;
```

### undefined?

자바스크립트에서 제공하는 원시 타입의 값이다.

변수를 선언하면, 특정 메모리 주소가 확보되고, 확보된 메모리에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.

**이는 자바스크립트의 독특한 특징이다.**

### 자바스크립트 엔진의 변수 선언 단계

1. 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고, 암묵적으로 undefined로 초기화.

- var 키워드를 사용한 변수 선언은 선언과 초기화 단계가 동시에 진행된다.

### 실행 컨텍스트(Execution Context)

자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행결과를 실제 관리하는 영역.

자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.

- 모든 식별자는 실행 컨텍스트에 등록된다.
- 변수 이름과 변수 값은 실행 컨텍스트 내에 키/값(key/value) 형식 객체로 등록되어 관리된다.

### 초기화

변수가 선언된 이후 최초로 값을 할당하는 것.

초기화가 없다면, 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. ⇒ 이를 **쓰레기 값**이라고 한다.

값을 할당하지 않고 곧바로 변수를 참조하면 쓰레기 값이 나올 수 있다.

### ReferenceError(참조 에러)

흔히 볼 수 있는 에러로, 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 등장하는 에러.

```jsx
Uncaught ReferenceError : average is not defined at <anonymous>:1:1
```

### 변수 호이스팅

```jsx
console.log(score);
var score;

// undefined 출력
```

위 코드에서, score는 선언 이전에 실행되기때문에 에러가 발생할 것으로 예상된다.

하지만 결과는 undefined인데, 그 이유는 자바스크립트 엔진이 **런타임 이전에 평가과정을 거치면서 모든 선언문(변수, 함수 등)을 찾아내 먼저 실행**하기 때문이다.

변수 선언이 소스코드의 어디에 있든 상관 없이 다른 코드보다 먼저 실행된다.

이처럼 **변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 특징을 변수 호이스팅** 이라고 함.

변수 뿐만 아니라, var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자(함수, 변수, 클래스)는 호이스팅 된다. ⇒ 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문.

### 값의 할당.

= 연산자를 사용해서 변수에 값을 할당.

```jsx
var score;
score = 80;

// 이를 약식으로 표현
var score = 80;
```

위 두개의 코드는 정확히 동일하게 실행되는데, 그 이유는 자바스크립트 엔진이 약식표현도 2개의 문장으로 나누어서 각각 실행하기 때문.

### 중요한 점은, 변수 선언과 값의 할당 실행 시점이 다르다는 점 !

- 변수 선언은 런타임 이전에 실행.
- 값의 할당은 런타임에 실행.

이때, 런타임이란, 소스코드가 순차적으로 실행되는 시점을 뜻함.

### 값의 재할당.

재할당은 변수에서만 가능하며, 값이 변할 수 없는 “상수”에서는 불가능하다.

이전 값이 저장되어있던 메모리 공간을 지우고 새로운 값을 해당 공간에 저장하는 것이 아닌, **새로운 메모리 공간을 확보하고 그 메모리 공간에 새로운 값을 저장**한다. 식별자(변수 이름)는 새로 확보된 공간과 연결된다.

이전 값이 저장되어 있던 공간은 그 어떤 식별자와도 연결되어 있지 않으므로, **가비지 콜렉터**에 의해 자동으로 메모리에서 해제된다.

### 가비지 콜렉터?

할당한 메모리 공간을 주기적으로 검사하여, 더 이상 사용되지 않는 메모리, 즉 **어떠한 식별자도 참조하지 않는 메모리 공간을 해제**하는 기능.

- 기능 : 메모리 누수 방지

### 매니지드 언어, 언 매니지드 언어

- 메모리 관리 방식에 따른 언어 분류
- 개발자 주도하에 메모리 제어를 할 수 있다면 언매니지드 언어. ex) C언어
- 언어 차원에서 메모리 제어를 할 수 없게 제한하는 매니지드 언어. ex) 자바스크립트

### 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 단 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러기호($)로만 시작해야 한다. 즉, 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용 불가능하다.

![식별자 예약어](./pictures/%EC%98%88%EC%95%BD%EC%96%B4.png)

추가로, ES5 부터 유니코드를 지원하면서 한글, 일본어 변수명을 사용할 수 있으나, 알파벳을 제외한 유니코드 식별자를 사용하는 것은 권장하지 않는다.

변수명은 대소문자를 구문한다. (student ≠ STUDENT)

### 네이밍에서 가장 중요한 점은, 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확하게 표현해야 한다는 것이다.

별도의 주석을 통해 설명이 필요하다면 변수의 목적이 명확히 드러나고 있지 않은 것이다.

```jsx
var x = 3; // 바람직하지 않다.
var score = 100; // 바람직하다.
```

### 네이밍 컨벤션?

하나 이상의 영어 단어로 구성된 식별자를 만들 때, 가독성을 높이기 위한 명명 규칙

1. 카멜 케이스(Camel Case)
2. 스네이크 케이스(Snake_case)
3. 파스칼 케이스(PascalCase)
4. 헝가리언 케이스(typeHungarianCase)

```jsx
var firstName; // 카멜 케이스
var first_name; // 스네이크 케이스
var FirstName; // 파스칼 케이스

// 헝가리안 케이스
var strFirstName; // type + identifier
var $elem = document.getElementByID("myId"); // DOM 노드 표현 시 달러 표기
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

- 일반적으로, 변수나 함수는 카멜케이스
- 생성자 함수, 클래스 이름에는 파스칼 케이스 사용.

⇒ 즉, 가독성을 높이려면, 카멜케이스와 파스칼케이스를 사용하는 것이 유리함.
