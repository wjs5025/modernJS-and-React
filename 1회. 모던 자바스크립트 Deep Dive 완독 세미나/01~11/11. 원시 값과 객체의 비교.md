### 자바스크립트의 타입구분

- 원시타입 : 변경 불가능한 값.(immutable value)
  (7개) 숫자, 문자열, 불리언, null, undefined, 심벌, 객체
  변수(확보된 메모리 공간)에 실제 값이 저장된다.
- 객체타입 : 변경 가능한 값(mutable value)
  변수(확보된 메모리 공간)에 참조 값이 저장된다.

### 원시 값

- 변경 불가능한 값(immutable value)으로, 읽기 전용이다.

### 변수와 값의 구분 + 상수

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간이며, 그 공간을 식별하도록 붙인 이름
- 값 : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
- 상수 : 변수는 재할당으로 값을 교체할 수 있지만, 상수는 재할당이 금지되어 있어서 교체 불가능

### 원시 값의 재할당

- 변수의 값을 재할당하면, 기존 변수가 가리키던 메모리 주소 대신 새로운 값이 들어있는 새로운 주소를 가리키게 한다

### 유사배열 객체

- 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체. 또한 for 문 순회도 가능
  예시 : 문자열 객체
- 그렇다면, 문자열은 원시값? vs 객체?
  문자열은 원시 값이며, 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환됨.
- 문자열은 원시 값이므로, 변경할 수 없다. 아래 예제는 오류는 발생하지 않지만 값이 변경되지도 않는다.
  ```jsx
  let str = "string";
  str[0] = "K";
  console.log(str); // string
  ```

### 다른 변수로의 할당 \*\*\*

- 원시값을 다른 변수에 할당하면 원시 값이 복사되어 전달된다. **(pass by value)**
  엄연히 말하면, 새로운 공간에 값을 복사하고, 그 공간의 메모리 주소를 전달.
- 객체 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨. **(pass by reference)**

```jsx
// 배열은 객체타입이므로,
// 여러 개의 식별자(array, copy_array)가 한 개의 객체를 공유하는 현상(부작용)이 나타남
let array = [1, 2, 3];
let copy_array = array;

array.push(4);
console.log(copy_array); // Array [1, 2, 3, 4]

let string = "abc";
let copy_string = string;

string = "abcdef";
console.log(copy_string); // "abc"
```

### 자바스크립트의 객체 관리 방식

- 프로퍼티 키를 인덱스로 사용하는 해시테이블이라고 생각할 수 있음.
- 프로퍼티와 메서드가 정해져있는(클래스 기반) 언어들(자바, C++)은 객체 생성 이후 프로퍼티를 삭제하거나 추가할 수 없는 반면,
  자바스크립트는 동적으로 프로퍼티와 메서드를 추가할 수 있다.
  → 이는 사용하기 편하다는 장점이 있지만, 성능과 비용측면에서는 큰 단점이고 비효율적이다.
  → 따라서, 자바스크립트 V8엔진은, 프로퍼티 접근에 동적 탐색 대신 히든 클래스라는 방식을 사용하여, C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장함.
  - V8 히든클래스 검색 참고.

### 변경 가능한 값.

- 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값이다.(Mutable Value)
- 변수에 객체를 할당하면, 참조값(생성된 객체가 저장된 메모리 공간의 주소)이 변수에 저장된다.
  **변수에 할당된 메모리 주소가, 또다른 메모리 주소(객체가 저장된 곳)을 가리킨다고 생각하면 됨.**
  반면, 원시 값을 할당한 변수는 원시 값 자체를 값으로 가짐.
- 객체를 할당한 변수는 “변수는 객체를 참조하고 있다” 또는 “변수는 객체를 가리키고 있다”라고 표현.
  반면, 원시 값을 할당한 변수는 “변수는 O값을 갖는다” 또는 “변수의 값은 O다”라고 표현함.
- 원시 값과 달리, 객체는 값을 변경,수정할 수 있다. (프로퍼티 추가, 삭제, 갱신 등)

### 얕은 복사와 깊은 복사

```jsx
const o = { x: { y: 1 } };

// 얕은 복사
const c1 = { ...o }; // spread 문법
console.log(c1 === o); // false
console.log(c1.x === o.x); // true (객체 내부의 객체까지는 복사하지 않음)

const _ = require("lodash");

// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false

// ** 객체 간 === 비교시, 참조 값을 비교
// 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사라고 부르는 경우도 있음.
// 추가로, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고 부르는 경우도 있음.
// 즉, 참조를 공유하느냐 안하느냐의 차이
const v = 1;

// 깊은 복사로 부르기도 함.
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1 };

// 얕은 복사라고 부르기도 함.
const c2 = o;
console.log(c2 === o); // true
```

### 실행 결과 예측하기

```jsx
let person1 = {
  name: "Jeon",
};

let person2 = {
  name: "Jeon",
};

console.log(person1 === pserson2); // ?? -> false (참조 값이 다르기 때문)
console.log(person1.name === person2.name); // ?? ->  true (원시값끼리 동일하기 때문)
```
